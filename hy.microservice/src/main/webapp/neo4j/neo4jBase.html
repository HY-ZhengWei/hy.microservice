<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>Neo4j</title>
    
    <script type="text/javascript" charset="utf-8" src="../jquery/jquery.min.js"></script>
    <script type="text/javascript" charset="utf-8" src="../d3/d3.min.js"></script>
    <script type="text/javascript" charset="utf-8" src="../d3/hy.common.d3.js"></script>
    <script type="text/javascript" charset="utf-8" src="neo4j.webSocket.js"></script>
    
    <style type="text/css">
    body { 
        background-color: white; 
        overflow-x: hidden;
        overflow-y: hidden;
        width: 100vw;
        height: 100vh;
    }

    #Test {
        position: fixed;
        top: 0px;
        left: 0px;
    }
    </style>
</head>
<body oncontextmenu="return false">

    <svg width="100%" height="100%" version="1.1" xmlns="http://www.w3.org/2000/svg"></svg>
    
    <div id="Test">测试</div>
    
<script type="module">
d3.json("neo4j.cdc.json")
.then(function (i_Datas) 
{
  // Specify the dimensions of the chart.
  const width  = document.body.clientWidth;
  const height = document.body.clientHeight;
  console.log("加载数据成功，准备初始化。w=" + width + " ,h=" + height);
  
  // Specify the color scale.
  const color = d3.scaleOrdinal(d3.schemeCategory10);
  
  // The force simulation mutates links and nodes, so create a copy
  // so that re-evaluating this cell produces the same result.
  const links = i_Datas.links.map(d => ({...d}));
  const nodes = i_Datas.nodes.map(d => ({...d}));
  
  // Create the SVG container.
  const svg = d3.select("body").select("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [0, 0, width, height])
        .attr("style", "max-width: 100%; height: auto;");
        
  // Add a line for each link, and a circle for each node.
  const link = svg.append("g")
        .attr("stroke-opacity", 0.6)
        .selectAll()
        .data(links)
        .join("line")
        .attr("id" ,function(d) 
        {
            return "line_" + d.source + "_t_" + d.target;
        })
        .attr("sourceID" ,d => d.source)
        .attr("targetID" ,d => d.target)
        .attr("stroke-width", d => Math.sqrt(d.width))
        .attr("stroke", d => d.lineColor ? d.lineColor : "#999");
        
  const linkAnimation = svg.append("g")
        .attr("id" ,"linkAnimation");

  const node = svg.append("g")
        .attr("stroke-width", 1.5)
        .selectAll()
        .data(nodes)
        .join("circle")
        .attr("id" ,d => "node_" + d.id)
        .attr("r", d => d.size / 2)
        .attr("stroke", d => d.lineColor ? d.lineColor : "white")
        .attr("fill", d => d.bgColor ? d.bgColor : color(d.group));
        
  const label = svg.append("g")
        .attr("text-anchor" ,"middle") 
        .attr("dominant-baseline" ,"middle")
        .selectAll()
        .data(nodes)
        .join("text")
        .attr("id" ,d => "label_" + d.id)
        .attr("shortName" ,d => d.shortName)
        .text("0")
        .attr("fill", d => d.fontColor ? d.fontColor : "white")
        .attr("font-size" ,d => d.fontSize ? d.fontSize : 12);
  
  node.append("title")
  .text(d => d.name);

  // Add a drag behavior.
  node.call(d3.drag()
        .on("start", dragstarted)
        .on("drag", dragged)
        .on("end", dragended));

  // Set the position attributes of links and nodes each time the simulation ticks.
  function ticked() {
    link
        .attr("x1", d => d.source.x)
        .attr("y1", d => d.source.y)
        .attr("x2", d => d.target.x)
        .attr("y2", d => d.target.y);
    
    node
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
        
    label
        .attr("x", d => d.x)
        .attr("y", d => d.y);
  }

  // Reheat the simulation when drag starts, and fix the subject position.
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  // Update the subject (dragged node) position during drag.
  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  // Restore the target alpha so the simulation cools after dragging ends.
  // Unfix the subject position now that it’s no longer being dragged.
  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }
  
    // Create a simulation with several forces.
  const simulation = d3.forceSimulation(nodes)
      .force("link", d3.forceLink(links).id(d => d.id).distance(function(d) {return d.length}).strength(0.1))
      .force("charge", d3.forceManyBody())
      .force("center", d3.forceCenter(width / 2, height / 2))
      .on("tick", ticked);
      
  console.log("初始化完成");
  webSocketInit();
})
.catch(function (i_Error) 
{
    console.log(i_Error);
});



d3.select("#Test").on("click" ,function ()
{
    
});
</script>

</body>
</html>